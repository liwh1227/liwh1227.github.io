# 00. 碳普惠系统演进

> 该项目是我入职当前公司到现在从0到1搭建和维护的项目，在整个系统的开发过程中遇到过很多问题，也做了相应的改造和升级，这篇文章就是复盘下项目一步步迭代到现在，踩过的坑有哪些这些坑有很多因素，当时的架构设计、表设计、链上合约设计等，也通宵加班救过火，都一步步的过来了。本文根据之前的设计文档和开发日志等信息，详细梳理每次重要升级都是为了解决什么问题，带来了哪些提升，牺牲了什么，通过这种方式来提升自己的架构能力。

## 1. 背景

本系统的核心业务愿景是构建一个“低碳行为激励闭环”：用户通过地铁、公交等绿色出行方式积累碳气泡，经由系统核算转化为链上碳积分，最终用于兑换实际权益。目前已落地为“青碳行”、“沪碳行”等多个 C 端应用。作为整个生态的核心，**Go Gateway** 系统扮演着连接互联网业务（Web2）与区块链网络（Web3）的“核心网关”角色。它承接上游 Java 业务后台的高频请求，负责核心的资产管理与价值流转。其核心职责包括：

- **方法学引擎**：依据碳减排标准，将用户的出行行为实时计算为碳积分。
- **碳资产管理**：管理积分的发放、流转与回收，采用类 UTXO 结构确保资产的可追溯性。
- **区块链交互**：作为可信代理，将核心数据上链存证，确保数据的不可篡改与公开透明。

## 2. 系统架构

### 2.1 整体架构设计

本系统采用分层治理的设计思想，整体架构演进经历了从“单体强耦合”到“核心业务与链交互分离”的过程。当前版本（V3.0）架构如图1所示，旨在解决高并发下的即时响应与区块链异步确认之间的速率失配问题。系统逻辑上分为四层：**接入层**、**业务应用层**、**基础设施层**、**区块链网络层**。

![](../../assets/碳普惠gateway架构v1.png)
*图1: 碳普惠系统架构*

### 2.2 核心模块

Gateway 不仅仅是一个简单的流量转发网关，它承载了应用层向区块链层过渡的核心治理逻辑。为了保障高可用性与数据安全性，我们在以下几个关键模块开发。
#### 2.2.1 服务平滑升级

为了实现系统在版本迭代时的零停机部署，我们设计了一套完整的服务生命周期管理机制。Gateway 内部维护了 `Worker Pool` 内存队列，如果直接杀死进程，会导致内存中积压的“积分计算”或“上链请求”丢失，造成用户资产损失。

- **实现方案**：
    
    - **信号监听**：在 `main.go` 中利用 `os/signal` 监听 `syscall.SIGINT` 和 `syscall.SIGTERM` 信号。
    
    - **两阶段停机**：
        
        1. **切断入口**：HTTP Server 收到信号后，立即停止接受新的 API 请求（Nginx 层面自动摘除流量）。
        2. **排空存量**：调用 `WorkerPool.Stop()`，利用 `sync.WaitGroup` 等待所有正在执行的 Goroutine 完成任务。配合 `context` 的超时控制，强制在规定时间（如 30s）内完成收尾，防止僵尸进程。

#### 2.2.2 密码学与身份管理模块

由于底层对接 Chainmaker 联盟链，每个用户在链上需要通过非对称加密的私钥进行交易签名。Gateway 承担了 **KMS** 的部分职责，屏蔽了复杂的密码学细节。

- **功能定位**：为 App 端用户生成并托管链上身份。
- **技术细节** (基于 `lib/crypto`)：
    
    - **密钥生成**：采用 **ECDSA (P256)** 椭圆曲线算法生成公私钥对 (`PrivateKey/PublicKey`)，兼顾了安全性与计算效率。
    - **证书颁发**：实现了符合 **X.509** 标准的证书生成逻辑。由于证书信息较大，所以采用了懒加载的方式，当用户首次发起上链交易时，为其签发用户证书 (`User Certificate`)，确立其在联盟链中的身份权益。
    - **存储安全**：私钥经过加密（读取服务器端的key加密）处理后存储于 `user_crypto` 表中，确保资产所有权与业务账号的强绑定。


#### 2.2.3 高并发上链请求削峰

有些业务请求(批量收集、低碳乘车抵扣)等对于区块链需要签名调用remote node service上链等，可能会产生延迟，进而影响业务端，所以我们通过引入缓冲channel构造了生产和消费模式来解决这种速率上的不匹配。核心思想就是，先落库，后投递，主要是怕遇到某些无法预估的异常情况，处于内存（channel）中的数据丢失导致，落库作为兜底，后续上链失败的交易会被cron job处理，将数据重新上链。

![](../../assets/bufferd-channel解耦高并发请求.png)
*图2: 通过channel解耦高并发上链请求*

#### 2.2.4 分表

在当前版本（V3.0）的gateway中，只是metro的出行数据就已经达到1亿2千万的级别，我们是从单表1000万开始分表的，当时也是根据业务的情况，考虑到后续的出行量增长，经过详细讨论我们按照userId % 30的规则来进行分表，在解决了数据量的问题同时也解决了查询和计算逻辑慢的问题，当然这中间也引入了一些其他问题，后面章节会讨论。分表后的业务逻辑如图3所示。

![](../../assets/碳普惠-shardtable.png)
*图3: 分表和路由*

### 2.3 其他模块

我们的服务是使用了云服务器做的部署，

- mysql: 业务层的基础数据，例如：出行数据、兑换信息、链上碳积分的映射、钱包信息、余额数据等；
- redis：当前主要为了实现分布式锁，服务是多实例部署，有些业务（如：碳积分兑换）需要防止分布式并发；
- rabbitMQ：某些异步通信的数据；

除此之外，应用层的所有服务都是通过docker容器的方式运行，通过`docker-compose.yaml`做编排。

## 3. 系统演进与思考

碳普惠 Gateway 作为连接业务与区块链的核心枢纽，其架构并非一蹴而就，而是随着业务形态的变化和数据规模的增长，经历了从“简单存证” -> “资产管理” -> “高并发治理”的三个主要阶段。截止当前（2026.01），系统已稳定支撑亿级数据规模。本章将从架构设计、数据模型与合约逻辑三个维度，复盘每一次版本迭代背后的**痛点、决策逻辑与技术权衡**。
### 3.1 V1.0: 存证模式

在项目初期，业务目标主要是验证低碳行为上链的可行性。此时 App 端承载了所有的积分计算与账户体系，Gateway 主要完成上链的sdk封装和存证所需的hash计算等逻辑。我们采用单体架构。Gateway 内部直接集成 Chainmaker SDK，HTTP 服务与上链逻辑运行在同一进程中。
### 3.1.1 数据模型：

- **链下**：仅存储 `chain_tx` (交易流水) 和 `user` (密钥托管)。
- **链上**：合约逻辑极简，仅提供 `save(hash)` 接口，将用户行为摘要 Hash 写入区块。

我们通过构造定时任务（Cron Job）实现简单补偿机制。扫描 `status='pending'` 的交易进行重试或报警。
### 3.1.2 思考与总结

当时只有我一个开发，并且还要部署的工作，所以也是和业务沟通过后，考虑到这些因素链上只将积分做存证，主要业务还是在APP端跑，这种设计极大地降低了部署与运维成本，当然存在一定的问题，例如系统几乎没有抗并发能力，且数据库中直接明文/简单加密存储私钥，存在安全隐患等问题。

---

### 3.2 V2.0：资产上链与 UTXO 模型的引入

随着业务升级，业务产品要求将碳积分确权为数字资产，而不仅仅是行为存证。这意味着 Gateway 需要接管积分的**发放、流转、兑换**全生命周期。
### 3.2.1 Account vs UTXO ?

这是 V2.0 最关键的架构抉择：链上积分模型该如何设计？

- **选项 A：余额模型 (Account Model)**
    
    - _逻辑_：像银行账户一样，只记录 `Balance`。
    - _优点_：存储小，逻辑简单，App 端现有逻辑就是余额模式，对接容易。
    - _缺点_：难以溯源。无法回答“这 10 个积分是哪一次坐地铁产生的”这一问题。
    
- **选项 B：对象模型 (UTXO)**
    
    - _逻辑_：每一笔积分都是一个独立对象 (`Unique Hash`)，消费时销毁旧对象，生成新对象。
    - _优点_：**可追溯性极强**。完美契合碳普惠全流程减排审计的业务愿景。
    - _缺点_：数据膨胀快，并发冲突处理复杂。
    

**最终决策**：为了突出区块链可信溯源的核心价值，我们选择了类 UTXO 的对象模型，模型大致如下：

```go
// 链上积分结构示意
type Integral struct {
    Hash       string `json:"hash"`       // 唯一标识 (UTXO Key)
    Value      int    `json:"value"`      // 面额
    ParentHash string `json:"parentHash"` // 父hash
    Status     int    `json:"status"`     // 0: Unspent, 1: Spent
    SourceId   string `json:"sourceId"`   // 链下溯源id
    SourceType int    `json:"sourceType"` // 地铁/公交/单车
}
```

### 3.2.2 遇到的坑与反思

这一阶段虽然实现了资产化，但也踩了几个深坑：

1. **数据膨胀陷阱**：UTXO 模型导致数据量是 Account 模型的数十倍。随着用户高频出行，链上和 DB 中的积分记录呈指数级增长，为后续 V3.0 的存储瓶颈埋下了伏笔。
2. **合约随机数不一致**：在合约中使用 Go 的 `map` 遍历顺序不确定性，导致不同节点执行结果不一致（读写集冲突），引发共识失败。**教训：合约逻辑必须绝对确定性。**
3. **平台账户大爆炸**：所有用户兑换权益都指向同一个平台账户。平台账户持有了数百万个 UTXO 对象，每次查询或转账都会加载巨大的读写集，导致交易超时。**教训：高频账户必须做分片或特殊处理。**
### 3.3 V3.0：数据治理与服务化

v3.0版本中，是在APP和gateway并行稳定运行一段时间后，发现没有必要做这种镜像的操作，于是准备将关于碳的全部业务都搬到gateway（区块链）上。在该阶段，相对于碳的流转逻辑已经很成熟了，更多的是并发和业务数据量的问题。随着青岛地铁和APP的用户打通，数据量的增长已经非常快了。我们同APP部门做了大量的梳理工作，主要是针对定期活动期间可能存在被高并发访问的接口、一些核心业务逻辑的涉及到的调用链路等。

我们做的升级和优化手段在第二章已经做过了介绍，虽然数据表做了分表处理，但还是又一些并发查询请求是基于积分对象方式没法很好支持的，例如活动的界面（不止活动，日常可能并发不高分表后已经能应对）中查询用户碳积分余额就没法很好的应对，于是我们又引入了`balance`表来替代通过`sum`的方式查询用户余额的需求。还有就是，后面又要给运营和财务同事推数据报表，分表后你需要聚合30个表来完成整体的数据查询逻辑，这也是分表后带来的问题之一（虽然做方案的时候已经预料的该问题，但后面还是很痛😖！！！）。

同样的，节点数据也逐步增长到了一个很大的量级，尤其是当前联盟链的现状，节点虽说名义上归不同的组织管理，但实际上，都是由我们区块链团队去维护，所以控制节点服务器的成本也是日常维护中很重要的工作。我们通过对静态（已存在的数据）和动态（新产生的数据）两方面进行了优化。

**动态优化**：

- 根据业务的需求对上链的合约逻辑做了优化（可以打包的交易打包上链尽量压缩交易接口的调用）；
- 删除或合并合约数据结构和中间没有必要的世界状态的实现；
- 证书压缩，减少链上用户的权限数据；

 **静态归档**：

- 服务器硬盘成本较高，nas存储成本较低，于是我们保留了两个全节点在服务器硬盘，并将其他节点数据迁移到了nas上；
- 后面引入了归档中心（官方提供的工具），将部分节点数据迁移到了归档中心；

还有一部分关于将调用节点的能力从gateway中抽取出来的升级，老版本的gateway通过在代码中封装sdk来完成对区块链的访问，其实一开始组里的开发人手不足，关于sdk部分的逻辑变动并不大，所以采用这种单体的设计方便开发和维护。后来人手相对充裕，考虑如果将访问区块链的能力从gateway抽象出去会更方便维护，尤其是不想让gateway的升级影响访问区块链的能力，也不想让升级区块链影响业务的能力，所以将基于sdk封装了一个单独的服务，并对gateway提供上链的逻辑。其实微服务有微服务的好处，比如后续我们一些其他的上链业务直接复用了该服务的功能，并且维护该服务是组里单独的人员，开发上的心智负担更低。

>如果当前整个组还是我自己一个开发，那么我可能不会将sdk微服务化，毕竟一旦拆分出去，因为你需要额外维护一份代码库、服务实例本身等，这样做并没有因为拆分而带来什么提升。
### 3.4 小结

回顾从 V1.0 到 V3.0 的演进历程，我们始终在做限制条件下的最优解：

1. **业务驱动架构**：从 MVP 的单体，到资产化的 UTXO，再到高性能的分库分表，每一次升级都是被真实的业务痛点倒逼出来的，没有过度优化是我一直比较信奉的准则。

2. **没有银弹**：
    
    - 选择了 UTXO 带来了极致的溯源能力，却牺牲了存储效率，迫使我们后期不得不做复杂的分表和归档。
    - 选择了分表解决了 C 端高并发，却让 B 端统计查询变得异常痛苦。

尽管过程中经历了通宵救火和填坑，但系统核心架构（Go Gateway + MySQL + Chainmaker）一直保持了良好的延续性，没有发生推倒重来的灾难性重构，证明了早期技术选型的合理性。

## 4. 总结

其实作为在国内的联盟链开发从业者，在实际开发中一直处于比较尴尬的位置，有些不了解的人甚至认为区块链的什么都能干，当然也有人认为区块链就是个噱头。所以面对业务时，你必须晓之以理，动之以情，什么样的数据该上链，什么数据上链后风险（技术上的、隐私性上的等等）很大，甚至和其他部门的开发沟通时，你都必须评估清楚了，否则挖的坑就得自己填。当然，没有万能的架构，我们做技术就是为业务服务的，当前的架构能够支撑起业务，那我认为就是一个不错的架构。我们这个项目也是在小心翼翼中迭代到今天，还有很多问题没有解决，例如：链上和链下的积分冗余问题、当前用户的碳积分模型是否有必要继续沿用、用户的乘坐数据隐私问题、跨链需求等，这些都是后面会面临和需要解决的问题。