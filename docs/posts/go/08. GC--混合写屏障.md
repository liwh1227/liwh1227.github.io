# 08. GC--混合写屏障

## 1. 并发下的“对象丢失” 

在上一篇中我们提到，三色标记法如果没有任何保护措施，在并发场景下会导致严重的**悬挂指针**问题。这是因为用户程序 (Mutator) 和回收器 (Collector) 在同时修改对象图。要发生对象丢失，某个本应存活的对象因为在并发写入中“绕过了灰色波前”，最终仍保持白色并被错误回收。

### 1.1 必要条件

1. **条件一**：mutator 插入了一条从 **黑对象 → 白对象** 的新引用。
    
    - *黑对象按三色语义已经“扫描完成”，GC 不会再扫描它，因此这条新边可能永远不会被 GC 看到。*

2. **条件二**：mutator 删除了从 **灰对象 → 该白对象** 的所有引用。
    
    - *灰对象本应在后续被 GC 扫描并发现白对象，但“还没扫描到”就把路径断掉了。*

当 上述条件同时发生时，白对象可能既不在根可达集合里，也不会被灰色波前触达，于是保持白色直至清扫阶段，导致错误回收。


![](../../assets/gc-并发对象丢失灾难.png)
*图1:黑色对象引用白色对象导致错误回收问题*

如图1所示，初始状态下，objectA是黑色对象，其不会再被gc标记扫描，objectB是灰色对象已被标记在work queue中等待扫描，objectC则是白色对象。由于go是支持并发垃圾回收的，即GC的情况下用户代码仍然可以运行。

- 用户代码做了修改，将objectA指向了ObjectC，注意此时ObjectC还未被GC所标记；
- ObjectB此时被修改，指向了nil，此时，ObjectC的引用只有ObjectA；
- 根据GC的原理，ObjectA是不会再被扫描了，这也意味着ObjectC无法被标记，那么在垃圾回收中Object就会被当作垃圾回收，下次访问ObjectA指向的对象时就会出现指针悬空问题。

---
## 2. 强弱三色不变性 

为了阻止上述并发灾难，经典理论给出两类约束（不变式）。只要能保证其中之一，对象就不会“丢失”。

### 2.1 强三色不变性

规则：禁止黑对象指向白对象。  
一旦某个白对象被黑对象引用，就必须把白对象“提升”为灰（至少保证后续会被扫描/标记闭包覆盖）。对应思路：**Dijkstra 插入屏障**。

### 2.2 弱三色不变性

规则：允许黑→白，但要求白对象必须仍被灰色路径“保护”，即从某个灰对象仍可达。  
这类约束背后的直觉是：即使出现黑→白，只要白对象还在灰色波前之后，那么最终仍会被扫描到。对应思路：**Yuasa 删除屏障**（保护旧引用，避免“保护边”被删除导致白对象脱离灰色波前）。

---
## 3. Go 的演进：从插入屏障到混合写屏障

### 3.1 Dijkstra 插入写屏障

它的思路很简单：**“既然黑色不能指白色，那我就强制把白色染灰。”** 每当在堆上写入指针 `A.ptr = C` 时，不管 A 是黑是白，都把 C 涂成灰色。因为栈没有屏障，栈上的黑色对象可能引用白色对象。所以 GC 结束前，必须 **STW**，把所有栈重新扫描一遍，这导致了一定程度的延迟。

### 3.2 混合写屏障

为降低 STW尾部成本，Go 引入了**混合写屏障**，把“保护旧值（删除屏障思想）”与“保护新值（插入屏障思想）”组合在一起。

**核心逻辑：** 任何指针操作 `slot = ptr` (将 `ptr` 写入 `slot` 位置)，在汇编层面都会被替换为：

```go
writePointer(slot, ptr)  // slot 在堆上（heap slot）
    // 1) 删除屏障（Yuasa 思想）：保护旧引用，避免“保护边”被断开
    shade(*slot)

    // 2) 插入屏障（Dijkstra 思想）：保护新引用，避免黑→白漏标
    shade(ptr)

    // 3) 真正写入
    *slot = ptr
```

_注意：Go 的实际实现做了优化，具体表现为：被覆盖的指针（旧值）强制置灰；新分配的对象直接标黑。_

![](../../assets/gc-混合写屏障-1.png)
*图2: 混合写屏障*

### 3.3 引入混合写屏障后的收益

混合写屏障最大的贡献在于：**它允许栈操作完全无屏障，且无需最终重新扫描**。其关键保障如下：

- **栈扫描只需要在并发标记开始时完成一次**：GC 在进入并发标记前会短暂停顿（STW）以完成根扫描（包括栈根）。此后并发标记阶段不再依赖“末尾再 STW 全量重扫栈”。
- **并发标记期间，堆上的指针写入由混合写屏障兜底**：对堆 slot 的写入同时保护旧值与新值，避免“保护边断裂”和“黑→白插入”两类漏标条件同时成立。
- 在并发标记期间，新分配对象往往会被直接视为已标记（或快速纳入可达集合），减少“栈写入无屏障”可能带来的遗漏风险。

上述关键机制意味着，一旦栈被扫描过一次，它就绝对安全了，GC 结束时不需要再次暂停程序去检查栈。图3展示了两种不同策略下stw的时间对比，引入混合写屏障后，stw的时间几乎可以不计。

![](../../assets/gc-hybrid-stw对比.png)
*图3: stw时间对比*

---

## 4. 总结

- **并发风险**：在三色并发标记下，若同时发生“黑→白新引用插入”与“灰→白保护边删除”，白对象会漏标并在清扫时被错误回收。
- **理论约束**：强/弱三色不变式分别对应插入屏障（Dijkstra）与删除屏障（Yuasa）的不同保护思路。
- **混合写屏障价值**：对堆指针写入同时“保护旧值 + 保护新值”，配合一次性的栈根扫描与分配黑化等策略，使 Go 能在保证正确性的前提下避免末尾 Stack Rescan 的长 STW，从而获得更稳定的低延迟 GC 表现。