---
title: gmp模型
description: 关于go gmp模型的知识梳理
date: 2026-01-01
tags:
  - Go
  - Runtime
---

# GMP
## 1. 背景

go引入了goroutine为了解决c10k的问题，传统的并发模型中往往依赖于系统线程提供的能力来解决问题，而thread本身存在占用空间大、上下文切换慢等问题，一般情况下，线程占1mb-8mb，若尝试创建10000个线程，那么就大概占用几百g的内存空间，并且线程的调度需要操作系统内核完成，上下文的切换也存在效率问题，并且内核调度器的视角是线程，其不会对特定编程语言层面做调度上的优化。

go设计者意识到上面的问题，所以在go的设计中引入了用户态线程--goroutine。其设计初衷为了解决以下核心问题：

- **动态栈管理：** Goroutine的初始栈空间极小（Go 1.0时期为4KB，Go 1.2优化为2KB），并能根据需要动态伸缩 。这种设计使得在一个进程内运行数百万个Goroutine成为可能。   
- **廉价的上下文切换：** Goroutine的切换完全在用户态进行，无需陷入内核。调度器只需保存极少量的寄存器（PC, SP, DX等），切换成本仅为纳秒级，仅为OS线程切换开销的十分之一甚至更低 。   
- **同步编程模型，异步执行机制：** Go试图为开发者提供符合人类思维习惯的同步阻塞式编程接口（例如直接调用 `net.Conn.Read`），而运行时（Runtime）底层则利用I/O多路复用（如epoll）将其转化为非阻塞的异步执行，从而屏蔽了复杂的异步回调逻辑 。

Go选择了M:N的线程模型，即M个Goroutine被复用在N个操作系统线程上。这种模型试图结合1:1模型的并行能力和N:1模型的轻量级特性，但其实陈与调度的复杂性也随之而来。

## 2. GMP的演进

Go 1.0及之前的版本采用了一个相对朴素的调度器架构，后世称之为GM模型。这一时期的调度器虽然实现了基本的M:N映射，但在高并发场景下暴露出严重的可扩展性缺陷。
### 2.1 GM模型

GM模型主要由两个核心实体组成：

- **G (Goroutine)：** 代表并发执行的任务单元，包含栈信息、指令指针等状态。
- **M (Machine)：** 代表操作系统内核线程，是执行指令的实体。M由操作系统调度器管理。

在GM模型中，所有的Goroutine都维护在一个单一的**全局运行队列（Global Run Queue, GRQ）**中。任何一个M想要执行任务，都必须从这个全局队列中获取G，如下图所示。

![](../../assets/gm-model.png)
*图 1: GM 调度模型概览*

Dmitry Vyukov在2012年的[设计文档](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit?tab=t.0#heading=h.mmq8lm48qfcw)中详细剖析了这些问题，这些问题的核心矛盾点在于，g和m耦合太严重，m既是计算资源又是调度资源，于是Dmitry Vyukov在优化的方案中提出了GMP模型并在后续版本（go 1.1）进行了实现。
### 2.2 GMP模型
GMP模型的核心在于引入了第三个实体：**P（Processor）**。 P被定义为“执行Go代码所需的资源上下文”或“逻辑处理器”。在新的模型下：

- **G (Goroutine)：** 待执行的任务。
- **M (Machine)：** 工作线程，负责执行代码。
- **P (Processor)：** 调度上下文，维护本地运行队列。
![](../../assets/gmp-model.png)*图 2: GMP 调度模型概览*

**P的引入解决了什么问题？**

1. **去中心化锁：** 原本的全局运行队列被拆分。每个P拥有一个**本地运行队列**。当M绑定到一个P时，它可以无锁（或极低开销）地访问该P的本地队列，从而消除了全局锁的瓶颈 。   
2. **资源隔离与解耦：** 内存缓存从M移动到了P上。这意味着，当M因为系统调用阻塞时，P可以与M分离，并将P及其持有的mcache资源传递给其他空闲的M使用。这一设计极大地提高了资源利用率 。   

### 2.3 运行时实体关系

在GMP模型中，M必须持有P才能执行Go代码。

- **GOMAXPROCS：** 定义了P的数量，通常默认为CPU核数。这决定了同一时刻并行执行Go代码的最大程度。
- **M与P的绑定：** M是执行者，P是资源。当G执行系统调用导致M阻塞时，P会与M分离，寻找新的M继续执行队列中的其他G，从而实现非阻塞的并发调度。

## 3. 核心调度机制

GMP模型不仅改变了数据结构，还引入了一套复杂的调度算法，以在去中心化的环境下保持负载均衡。

### 3.1 调度循环

Go调度器的核心是一个循环机制，M在持有P的情况下，不断通过以下优先级顺序寻找可运行的G ：   

1. **Check `runnext`：** 这是一个特殊的、容量为1的高优先级槽位。为了优化通信延迟，当一个G唤醒另一个G时，被唤醒的G会被放入`runnext`，M会优先执行它。
2. **Check Local Run Queue (LRQ)：** M访问绑定P的本地队列。这是最快路径，通常无锁。
3. **Check Global Run Queue (GRQ)：** 为了防止全局队列中的G被“饿死”，调度器会以一定的频率（每61次调度循环）强制检查一次全局队列。
4. **Network Poller：** 检查是否有网络I/O就绪的G。
5. **Work Stealing（工作窃取）：** 如果上述均为空，M会尝试从其他P的本地队列中“窃取”任务。