# 13. 并发同步--mutex & rwmutex

!!! abstract "Abstract" 

	**Keywords**: *Mutex, 混合锁, 饥饿模式, 写锁优先, CAS*


---

## 1. 概述

Go 语言的 `sync.Mutex` 并非直接封装操作系统的互斥量（如 `pthread_mutex`），而是在用户态实现了一套复杂的自旋+信号量混合锁机制。其核心设计目标是在保持高吞吐量的同时，兼顾调度的公平性，并解决传统自旋锁在高并发场景下的 CPU 浪费问题以及操作系统锁在低竞争场景下的上下文切换开销。

---

## 2. 内存布局与状态位图

`sync.Mutex` 的源码定义（位于 `src/sync/mutex.go`）极为精简，其核心逻辑完全依赖于对 `state` 字段的控制。

### 2.1 结构体定义

```go
type Mutex struct {
    state int32  // 核心状态位图 (Bit Map)
    sema  uint32 // 信号量地址，用于 Goroutine 的挂起与唤醒
}
```

### 2.2 state 字段的位图解析

`state` 字段是一个复合状态指示器，`runtime` 通过位掩码技术将其划分为四个逻辑区域，以实现极致的内存复用：

1. **Locked (Bit 0)**: 锁定标识位。
    
    - `0`: 锁未被持有。
    - `1`: 锁已被持有。
    
2. **Woken (Bit 1)**: 唤醒标识位。
    
    - 表示是否有 goroutine 已被唤醒或正在自旋，准备抢锁。
    - **作用**：通知解锁者无需再从队列中唤醒新的 goroutine，从而避免不必要的竞争和上下文切换。
    
3. **Starving (Bit 2)**: 饥饿模式标识位。
    
    - `1`: 锁进入饥饿模式，启用严格 `FIFO` 调度。
    
4. **WaiterShift (Bit 3-31)**: 等待者计数器。
    
    - 存储当前正在等待该锁的 goroutine 数量。

mutex state的位图内存布局如下所示：

```Plaintext

+-------------------------------------------------------+-------------+
|               高 29 位 (Bit 31 - Bit 3)               | 低 3 位 (0-2)|
+-------------------------------------------------------+-------------+
|               等待者数量 (Waiters Count)                | Flags       |
|                 (atomic add 1<<3)                     | S | W | L   |
+-------------------------------------------------------+-------------+

```

---

## 3. 加锁流程

`mutex` 的加锁逻辑采用 fast path 和 slow path 分离的设计策略，以优化不同竞争程度下的性能。图1展示了G1和G2在竞争条件下获取锁的流程，主要展示在 fast path 和 slow path 的不同路径下实际采取的逻辑是什么。
![](../../assets/mutex-微观竞争与状态流转时序图.png)
*图1: Mutex 微观竞争与状态流转*

G1在stage1中获取锁的路径就是 fast path，G2发现G1持有锁后自旋和排队的过程就是 slow ptah。
### 3.1 Fast Path

这是最理想的情况。当 G 尝试获取锁时，如果当前 `state` 为 0（无锁、无等待、无饥饿），则直接通过一次 CAS 操作将 `Locked` 位置 1。

- **实现**：`CAS(state, 0, mutexLocked)`
- **开销**：仅一条汇编指令（如 `LOCK CMPXCHG`），无系统调用，延迟极低。

### 3.2 Slow Path

当 CAS 失败（锁已被持有或有等待者），G 进入 `lockSlow` 流程。该流程包含三个核心阶段：

#### 3.2.1 自旋

在挂起之前，`runtime` 会尝试让 G 在用户态进行有限次数的自旋（执行 `PAUSE` 指令，g仍处于`_Grunning`状态），期望锁能在短时间内被释放。

- **触发条件**：
    
    1. 锁处于正常模式（非饥饿）。
    2. 运行在多核 CPU 上。
    3. 当前 P 的本地运行队列为空（避免阻碍其他 G 运行）。
    4. 自旋次数未达到阈值（通常为 4 次）。
    

主要是利用 CPU 缓存，避免线程陷入内核态带来的上下文切换开销。

#### 3.2.2 计算期望状态

自旋结束后若仍未获取锁，G 需准备挂起。此时需计算 `state` 的新值：

- 若锁未释放，将 `WaiterShift` 计数加 1。
- 若 G 等待时间超过 1ms，设置 `Starving` 标志位。
- 若 G 是被唤醒的，需清除 `Woken` 标志。

#### 3.2.3 信号量排队

- G 调用 `runtime_SemacquireMutex`，将自己放入信号量队列。
- **状态变更**：G 的状态从 `_Grunning` 变为 `_Gwaiting`。
- **行为**：当前 M 释放 G，进入调度循环执行其他任务。

---

## 4. 调度模式：正常模式 vs 饥饿模式

这里的调度是指`runtime`如何对获取锁的流程做调度，例如下述代码逻辑：

```go
package main

import (
    "sync"
    "time"
)

// 1. 在用户态定义一把锁
var mu sync.Mutex 

func main() {
    // 启动 Goroutine 4 (G_Old)
    go func() {
        for {
            mu.Lock() // 3. 这里的行为受调度模式控制
            time.Sleep(100 * time.Millisecond) // 模拟持有锁
            mu.Unlock()
        }
    }()

    // 启动 Goroutine 2 (G_New)
    go func() {
        for {
            mu.Lock() // 3. 这里的行为受调度模式控制
            // ... 业务逻辑
            mu.Unlock()
        }
    }()
}
```

mu这把锁是G2持有还是G4持有是根据mutex的不同调度策略会有不同的效果。除了正常的调度模式外，go在后续版本引入了饥饿模式，旨在解决高并发场景下的**尾部延迟**问题，我们通过图2对比正常模式和饥饿模式的区别。
![](../../assets/mutex-调度模式对比.png)
*图2: 正常模式vs饥饿模式*

### 4.1 正常模式

- **触发条件**：当锁被释放时，唤醒等待队列队头的一个 G，被唤醒的 G 不会直接拥有锁，而是需要与新到达的 G 竞争。
- **可能存在问题**：新到达的 G 具有 CPU 亲和性，且已经在运行中，极大概率会在竞争中获胜。这会导致被唤醒的 G 抢锁失败，再次回到队列头部。

### 4.2 饥饿模式

- **触发条件**：当一个 G 等待锁的时间超过1ms。
- **机制**：**直接交接**
    
    - 解锁者将锁的所有权**直接交接**给等待队列队头 G。
    - 新到达 G 即使看到锁是空闲，也**禁止**抢占，必须直接去尾部排队。
    
- **退出条件**：
    
    - G 是队列中最后一个等待者。
    - G 等待锁的时间小于 1ms。
    
- **优势**：绝对公平，杜绝了长尾延迟。
- **代价**：吞吐量下降（强制进行了上下文切换）。

---

## 5. RWMutex：读写分离与优先级

`sync.RWMutex` 是基于 `sync.Mutex` 的扩展，用于实现读多写少的场景逻辑。

### 5.1 结构

```go
type RWMutex struct {
    w           Mutex  // 复用互斥锁，保证写操作之间的互斥
    writerSem   uint32 // 写阻塞信号量
    readerSem   uint32 // 读阻塞信号量
    readerCount int32  // 核心计数器：正数表示活跃读者，负数表示有写者正在等待
    readerWait  int32  // 记录在写锁请求时，剩余未离开的读者数量
}
```

### 5.2 写锁优先级机制

为了防止源源不断的读者导致写锁永远无法获取，`rwmutex`采用了**写优先**策略。

1. **加写锁 (`Lock`)**：
    
    - 首先获取内部互斥锁 `w.Lock()`（排除其他写者）。
    - **核心操作**：原子性地将 `readerCount` 减去一个巨大的常数 `rwmutexMaxReaders` (1 << 30)。
    - **效果**：`readerCount` 变为负数。后续新的读锁请求检测到负值，会立即阻塞并进入 `readerSem` 队列，不再允许加入。
    
2. **等待剩余读者**：
    
    - 将原有的 `readerCount` 值（即写锁请求时的读者数）加到 `readerWait` 中。
    - 如果 `readerWait > 0`，写者挂起，等待 `writerSem` 信号。
    
3. **释放读锁 (`RUnlock`)**：
    
    - 每个读者离开时，原子递减 `readerCount`。
    - 若检测到 `readerCount` 为负（说明有写者在等），则原子递减 `readerWait`。
    - 当 `readerWait` 归零时，最后一个读者负责唤醒写者。

读写锁的加锁流程如图3所示。

![](../../assets/13-并发同步-rwmutex-flow-1.png)
*图3: rwmutex加锁流程*

---

## 6. 总结

Go 的锁机制展示了系统级编程中对性能与公平的权衡：

- **Mutex**：通过 BitMap 压缩状态，利用Fast/Slow Path分离优化无竞争路径，通过**自旋**优化短等待，通过**饥饿模式**兜底长尾延迟。
- **RWMutex**：通过复用 Mutex 和翻转计数器的技巧，巧妙实现了写优先的读写分离，解决了读写锁中常见的写饥饿问题。