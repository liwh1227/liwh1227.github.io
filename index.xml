<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on liweihang's blog</title><link>https://liwh1227.github.io/</link><description>Recent content in Home on liweihang's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 01 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://liwh1227.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://liwh1227.github.io/about/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://liwh1227.github.io/about/</guid><description>个人简介 大家好，欢迎来到我的博客。
目前，在青岛居住和工作，从事区块链相关的工作，使用最多的是go语言。
我喜欢篮球、游戏、历史，现在在学习游泳🏊（2023.09.01）。
写这个博客的原因？ R1 这之前我所有的技术或日常博客散落在电脑、有道云笔记（2018-至今）、wolai（2022-至今）、infoQ（2022-至今）等不同处。
当我想把它们都整理至有道云笔记时，我发现有道云笔记的markdown编辑模式让人很头疼，一是我不喜欢它提供的编辑模式，二是某些附加功能需要收费。
于是我萌生出自己搭建blog的想法，我首选了hugo框架进行博客的搭建，并且我被其中的 no-style-please 主题所深深吸引，根据官网的配置，我搭建了一个简单的blog，其开始的模样如下：
R2 我希望这个博客够记录自己平时的一些想法，将自己日常输入（无论是读书、技术、或其他任何东西）转化为输出呈现出来。
博客里程碑 2023-09-01 基于hugo，使用 no-style-please主题搭建博客； 利用hugo的shortcodes功能，支持echarts； 图片等资源目前存储在七牛云的免费oss上； 2023-09-06 支持gitaction的自动部署，能够通过git管理blog的文章并推送部署至gitpages； todo 下面是关于本博客未来将要做的一些事情：
搭建blog到gitpages上，可通过互联网访问； 将其他地方的blog维护或迁移到此处； 读书笔记版块建立起来；</description></item><item><title>分布式数字身份（下）</title><link>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8B/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8B/</guid><description>0. 前言 上篇我们从DID的相关基础概念和组成进行了介绍，为了更进一步的了解DID的的概念，本篇文章从员工工作跳槽，现雇主公司需要验证入职员工工资流水进行定薪的场景展开。
主要从场景描述、具体描述这两部分进行介绍。
场景描述：介绍个人收入证明场景下，参与方、验证过程、并对比同传统验证方案的区别和优势； 具体实现：结合实际场景，对DID架构中所使用的DID标识、DID Doc、可验证凭证及可验证表述数据模型进行构建，并描述其中的验证过程和原理； 1. 场景描述 1.1 传统验证过程 员工入职现雇主公司并根据工资流水定薪是一个非常常见的应用场景，大致过程如下：
入职员工通过提交上一家的工资流水证明来证明自己薪资水平，该证明一般通过向银行申请获得； 入职员工携带必要的材料去银行进行工资流水证明申请； 银行验证相关信息后，为其打印工资流水证明，证明会附上银行的印章信息； 入职员工携带材料去入职，并将银行开具的工资流水证明提交给现雇主公司； 现雇主公司HR查看银行开具的工资流水证明，能够获知该员工的工资收入情况并根据实际情况进行定薪； 上述过程是传统流程下的证明开具和验证流程，参与方分别为入职员工、银行、现雇主公司，证明内容反映的信息为该入职员工上一家工资收入情况，印章则能够证明该证明是银行所开具。
1.2 基于DID验证过程 基于DID的验证流程思想上同传统验证过程类似，也是根据证明信息来验证用户收入情况，不同之处在于在DID的体系下，代表实体身份的是不同的DID及对应的DID Doc，代表证明信息的是可验证凭证和可验证表述。
入职员工、银行、现雇主公司会分别进行DID注册，并生成相应的DID Doc； 入职员工通过线上或线下方式向银行申请关于工资流水的可验证凭证； 入职员工将可验证凭证封装为可验证表述，通过线上或线下的方式提交给现雇主公司； 现雇主公司会查看入职员工所提交的可验证表述来验证入职员工的收入情况； 验证通过后，现雇主公司会根据之前的收入情况对入职员工进行定薪； 同传统验证过程相比，DID架构下，身份和凭证的合法性通过基于密码学的数学方法进行验证。由于可验证凭证遵循同一套规范去定义的结构，所以不同机构或种类的证明可以更具有通用性，不同凭证的区别则更多体现在了凭证本身需要证明的内容上面。
2. 具体实现 2.1 构建模型 DID &amp;amp; DID Doc 在该场景下，参与方有三个实体，分别是入职员工、银行、现雇主公司，生成的DID和DID Doc信息如下：
入职员工 DID：did:example:123456abcdef DID Doc { &amp;#34;@context&amp;#34;: &amp;#34;https://test.cn&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;did:example:123456abcdef&amp;#34;, &amp;#34;authentication&amp;#34;: [{ &amp;#34;id&amp;#34;: &amp;#34;did:example:123456abcdef#keys-1&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;Ed255519VerificationKey2018&amp;#34;, &amp;#34;controller&amp;#34;: &amp;#34;did:example:123456abcdef&amp;#34;, &amp;#34;publicKeyBase58&amp;#34;: &amp;#34;H3xxxslkMv5423MJHjnamjxiklijinklkjijkew&amp;#34; }], &amp;#34;service&amp;#34;: [{ &amp;#34;id&amp;#34;: &amp;#34;did:example:123456abcdef&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;VerifiableCredentialService&amp;#34;, &amp;#34;serviceEndpoint&amp;#34;: &amp;#34;https://test.cn&amp;#34; }] } 银行 DID：did:example:abcdef123456 DID Doc { &amp;#34;@context&amp;#34;: &amp;#34;https://test.</description></item><item><title>分布式数字身份（上）</title><link>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8A/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8A/</guid><description>0. 前言 本篇内容基于W3C分布式数字身份相关调研内容，结合官方文档和调研过程中自己的一些理解进行整理，计划使用两篇文章进行描述，此为上篇，主要描述分布式数字身份的基本概念。
1. DID 首先，我们看下w3c关于分布式数字身份的定义： 大致要点如下：
去中心化标识符（DID）是一种新型标识符，能够实现可验证的去中心化数字身份； DID的控制权是在DID持有者身份上，持有者可以是任何主体（例如人、组织、物品、数据模型、抽象实体等），并且可以与中心化的注册表、身份提供者和证书机构分离； 具体而言，虽然其他方可能用于帮助启用与DID相关信息的发现，但DID的设计使控制者能够在不需要其他方许可的情况下证明对DID的控制权。 2. DID Document 与DID成对存在的是DID Document，DID Doc是对DID主体信息的进一步描述。不同DID主体之间能够通过阅读对方（这个阅读一般指机器意义上的识别）DID Doc获取有用身份代表信息，例如能够代表主体身份公钥信息及对应的密钥算法。 以下是基于公钥内容的DID Doc示例1：
{ &amp;#34;@context&amp;#34;: [ &amp;#34;https://www.w3.org/ns/did/v1&amp;#34;, &amp;#34;https://w3id.org/security/suites/ed25519-2020/v1&amp;#34; ], &amp;#34;id&amp;#34;: &amp;#34;did:example:123456789abcdefghi&amp;#34;, &amp;#34;authentication&amp;#34;: [{ &amp;#34;id&amp;#34;: &amp;#34;did:example:123456789abcdefghi#keys-1&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;Ed25519VerificationKey2020&amp;#34;, &amp;#34;controller&amp;#34;: &amp;#34;did:example:123456789abcdefghi&amp;#34;, &amp;#34;publicKeyMultibase&amp;#34;: &amp;#34;zH3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV&amp;#34; }] } @context: 代表的是该JSON-LD格式结构上下文2含义，主要目的是通过通过该上下文获取该结构中各字段的具体含义；
id: DID唯一标识；
authentication: 该字段用于确认用户对该DID的控制权，包含了与DID相关的公钥信息，用于验证DID控制器的身份和控制权。具体来说，该字段中的公钥信息可以用于验证DID控制器的数字签名，从而证明DID控制器对DID的控制权。
3. 可验证凭证 如图，W3C对可验证凭证定义： 一个标准的数据模型和表示格式，用于加密验证数字凭证，由W3C可验证凭证规范定义。
W3C定义的可验证凭证数据模型3：
{ &amp;#34;@context&amp;#34;: [ &amp;#34;https://www.w3.org/2018/credentials/v1&amp;#34;, &amp;#34;https://www.w3.org/2018/credentials/examples/v1&amp;#34; ], &amp;#34;id&amp;#34;: &amp;#34;http://example.edu/credentials/1872&amp;#34;, &amp;#34;type&amp;#34;: [ &amp;#34;VerifiableCredential&amp;#34;, &amp;#34;AlumniCredential&amp;#34; ], &amp;#34;issuer&amp;#34;: &amp;#34;https://example.edu/issuers/565049&amp;#34;, &amp;#34;issuanceDate&amp;#34;: &amp;#34;2010-01-01T19:23:24Z&amp;#34;, &amp;#34;credentialSubject&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;did:example:ebfeb1f712ebc6f1c276e12ec21&amp;#34;, &amp;#34;alumniOf&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;did:example:c276e12ec21ebfeb1f712ebc6f1&amp;#34;, &amp;#34;name&amp;#34;: [ { &amp;#34;value&amp;#34;: &amp;#34;Example University&amp;#34;, &amp;#34;lang&amp;#34;: &amp;#34;en&amp;#34; } ] } }, &amp;#34;proof&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;RsaSignature2018&amp;#34;, &amp;#34;created&amp;#34;: &amp;#34;2017-06-18T21:19:10Z&amp;#34;, &amp;#34;proofPurpose&amp;#34;: &amp;#34;assertionMethod&amp;#34;, &amp;#34;verificationMethod&amp;#34;: &amp;#34;https://example.</description></item><item><title>0-n-1 缺失的数字</title><link>https://liwh1227.github.io/code/0-n-1%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://liwh1227.github.io/code/0-n-1%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid><description>题目描述</description></item><item><title>关于go服务不停机升级的方案</title><link>https://liwh1227.github.io/posts/%E5%85%B3%E4%BA%8Ego%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%BA%E5%8D%87%E7%BA%A7%E7%9A%84%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://liwh1227.github.io/posts/%E5%85%B3%E4%BA%8Ego%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%BA%E5%8D%87%E7%BA%A7%E7%9A%84%E6%96%B9%E6%A1%88/</guid><description>背景 在Go语言中，优雅地结束服务是一个非常重要的问题，因为它直接关系到服务的可靠性和稳定性。在传统的服务结束方式中，直接使用os.Exit()或syscall.Exit()等方法来结束服务，会导致服务无法优雅地退出，可能会出现一些问题，如未处理完的请求、未关闭的连接等。
目前项目的go服务主要用于接受外部app请求，根据请求信息进行相应逻辑处理后，将信息落库和上链。
我们要做到服务的优雅关闭，需要保证下面几类功能模块能够处理完请求后才退出：
http模块能够处理完成当前请求后正确退出； 消息队列模块能够将待消费的消息处理完成后退出； 未处理完的逻辑、监听区块链事件未处理完的逻辑等，保证能够在处理完成上述逻辑后再退出gateway服务，并且能够再某一个服务实例退出后，其他服务实例仍然可以工作。 实现方案 主要思路 gateway服务退出后，需要保证仍然能够对外提供相应的接口服务；
gateway通过docker容器方式运行，当我们停止docker容器时，需要使用 docker-compose down 或 docker-compose stop 命令结束服务。这两条命令会向容器发送系统中断信号，所以我们首先要考虑如何在容器收到结束信号时通知到服务；
gateway服务会启动http模块、消息队列模块以及区块链模块这三部分异步任务，我们需要考虑在退出主协程时如何保证上述三个子协程处理的模块能够在处理完当前逻辑后退出；
我们基于上述的3个问题分别进行解决，并通过demo代码进行演示。
实施方案 1. 负载均衡 为了保证某个服务停止后，仍然有其他实例能够对外提供服务，我们必须要对当前服务做负载均衡，这里是让运维同事通过nginx对gateway服务做了负载。这样就能保证某个实例停服更新时，可以将外部请求负载到其他的服务实例上。
通过上述三步基本能够保证优雅停机升级服务，但是在某些细节上还需要进行优化。
2. 处理和监听系统信号 使用 docker-compose down 或 docker-compose stop 命令进行docker容器停止，容器会收到 SIGTERM 中断信号，所以我们需要在服务中针对该信号进行捕捉和处理，主要处理方法如下：
package main import ( &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;syscall&amp;#34; ) func main() { signals := make(chan os.Signal, 1) signal.Notify(signals, syscall.SIGTERM, syscall.SIGINT) &amp;lt;-signals // do logic... } 开始时， signals 处于阻塞状态，当接收到上述SIGTERM 或 SIGINT信号后，说明运行容器要停止，进行系统退出后的逻辑处理。这里有一点需要注意，当我们运行上述命令后，容器会有默认停止的超时时间（10s），当超过该时间后系统会发送 SIGKILL 信号，
该信号无法被捕捉，为了保证服务能够最大程度的处理完业务逻辑，我们需要在停止容器时添加超时时间的命令， 例如：docker-compose down --timeout 120，将最大超时时间设置为120s，当超过这个时间后才会发送 SIGKILL 信号。</description></item></channel></rss>