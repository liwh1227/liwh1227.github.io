<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on liweihang&#39;s blog</title>
    <link>https://liwh1227.github.io/</link>
    <description>Recent content in Home on liweihang&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://liwh1227.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>减肥第一周</title>
      <link>https://liwh1227.github.io/lose_weight/202309%E7%AC%AC%E4%B8%80%E5%91%A8/</link>
      <pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liwh1227.github.io/lose_weight/202309%E7%AC%AC%E4%B8%80%E5%91%A8/</guid>
      <description> 记录睡眠、饮食、运动的信息，一周一记，包括身体体重信息
时间：2023-09-04
day1 2023-09-04 早晨 黑咖啡 1杯 红牛（增强版）半瓶 饼两张 鸽子蛋 * 2 鸡肉若干、蘑菇半盘 中午 饼两张 蘑菇一盘 红牛 半瓶 鸡肉若干 下午加餐 瑞幸酱香型 一杯 运动 游泳2h 睡眠 中午15min，没睡好，可能好上午的☕️和红牛有关系； day2 2023-09-05 早晨 面条300g、海参1、虾1 中午 饼 * 3，菜 若干 午睡 20min 下午 拿铁咖啡 * 1 晚上 葡萄 * 100g 篮球 2h day3 2023-09-06 早晨 花卷 * 1 、西红柿炒鸡蛋、一碗小米汤 黑咖啡 * 15g </description>
    </item>
    
    <item>
      <title>基于DID的碳资产身份解决方案</title>
      <link>https://liwh1227.github.io/posts/%E5%9F%BA%E4%BA%8Edid%E7%9A%84%E7%A2%B3%E8%B5%84%E4%BA%A7%E8%BA%AB%E4%BB%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liwh1227.github.io/posts/%E5%9F%BA%E4%BA%8Edid%E7%9A%84%E7%A2%B3%E8%B5%84%E4%BA%A7%E8%BA%AB%E4%BB%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>0.背景 基于中心化或联邦化的凭证认证，用户的任何行为都会被记录，同时存在泄漏风险，对于用户而言是没有任何隐私； 各不同中心机构对于凭证的实现依照各自的标准进行，缺乏统一标准规范； 基于DID凭证认证，各参与方依照数学规范实现相应模型，通过密码学原理进行认证，更容易形成通用性的标准和规范； 以下方案基于用户持用碳资产凭证享受某种权益的过程，具体示例场景是用户产生过1t的碳减排可以享受某植物园门票打折优惠；
参与方：
碳资产运营方 用户 植物园 1.传统的碳资产权益凭证证明过程 碳资产运营机构根据用户碳资产的相关信息生成用户的碳资产凭证； 用户向植物园出示该电子凭证，植物园会对电子凭证进行核销，本质是调用颁发方（碳资产运营机构）的相应接口； 碳资产运营机构会根据用户存储在中心的信息返回结果； 植物园会根据实际结果决定用户是否享有打折权益； 2.基于DID的碳资产权益凭证证明过程 碳资产运营方根据用户的did信息和平台维护的碳资产相关信息为用户颁发可验证凭证； 用户持有该凭证到相应的验证机构进行凭证验证并享受相应的权益； 植物园根据用户提供的凭证进行验证，这部分验证一般不会涉及同颁发方的交互，会基于提前制定的验证规则进行验证； 植物园会根据实际结果决定用户是否享有打折权益； 3.方案对比 方案名称 隐私性 开发成本 通用性 中心化 ❌ ✅ ❌ DID ✅ ❌ ✅ 中心化 优势： 技术实现和验证逻辑方案成熟，目前大部分的电子凭证都是通过这种形式实现； 劣势： 用户隐私无法得到有效保证，用户何时、何地使用凭证都可能被中心机构所记录； 通过中心化机构数据正确性保证凭证内容不可篡改，并且强依赖于中心机构的服务稳定性； 不同中心针对同类型的证明实现形式各不相同，上述例子中如果是不同主体的碳资产运营机构，那么对于碳资产凭证的实现上肯定各不相同，缺乏统一标准； DID 优势： 隐私性，凭证颁发成功后就会通过用户手中进行流转，即用户何时、何地去进行凭证的验证中心机构都无法获知（不同业务场景存在不同情况）； 颁发的可验证凭证基于数字签名或其他数学方法的原理，能够保证凭证内容的不可篡改性； 能够实现一次颁发，处处使用，基于W3C的统一规范实现模型，有利于不同机构凭证形成统一规范； 劣势： 基于did的凭证验证方案技术实现上较为复杂，涉及到did注册表、验证服务、用户数字钱包等功能； did的方案目前还处于理论阶段，尤其是在不同did主体进行交互验证的方面缺乏标准化的工作； 总结 did的凭证解决方案中能够更好的保护用户隐私性，同时其涉及到较多的技术手段，带来了更多的开发和维护成本。
4.DID方案实现 碳资产运营机构、用户、植物园三方分别要先向did管理机构申请和生成did及对应的did doc； did和did doc是对应存在的，did doc是对did主体信息的描述。不同did主体之间能够通过阅读对方（这个阅读一般指机器意义上的识别）did doc获取有用身份代表信息，此处的例子就是did主体的公钥信息及对应的加密算法。
运营方：
did:example:yyf0001xxx
did doc:
{ &amp;#34;@context&amp;#34;: &amp;#34;https://test.cn&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;did:example:yyf0001xxx&amp;#34;, &amp;#34;authentication&amp;#34;: [{ &amp;#34;id&amp;#34;: &amp;#34;did:example:yyf0001xxx#keys-1&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;Ed255519VerificationKey2018&amp;#34;, &amp;#34;controller&amp;#34;: &amp;#34;did:example:yyf0001xxx&amp;#34;, &amp;#34;publicKeyBase58&amp;#34;: &amp;#34;H3xxxslkMv5423MJHjnamjxiklijinklkjijkew&amp;#34; }], &amp;#34;service&amp;#34;: [{ &amp;#34;id&amp;#34;: &amp;#34;did:example:yyf0001xxx&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;VerifiableCredentialService&amp;#34;, &amp;#34;serviceEndpoint&amp;#34;: &amp;#34;https://test.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://liwh1227.github.io/about/</link>
      <pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liwh1227.github.io/about/</guid>
      <description>个人简介 大家好，欢迎来到我的博客。
目前，在青岛居住和工作，从事区块链相关的工作，使用最多的是go语言。
我喜欢篮球、游戏、历史，现在在学习游泳🏊（2023.09.01）。
写这个博客的原因？ R1 这之前我所有的技术或日常博客散落在电脑、有道云笔记（2018-至今）、wolai（2022-至今）、infoQ（2022-至今）等不同处。
当我想把它们都整理至有道云笔记时，我发现有道云笔记的markdown编辑模式让人很头疼，一是我不喜欢它提供的编辑模式，二是某些附加功能需要收费。
于是我萌生出自己搭建blog的想法，我首选了hugo框架进行博客的搭建，并且我被其中的 no-style-please 主题所深深吸引，根据官网的配置，我搭建了一个简单的blog，其开始的模样如下：
R2 我希望这个博客够记录自己平时的一些想法，将自己日常输入（无论是读书、技术、或其他任何东西）转化为输出呈现出来。
博客历史 2023-09-01 基于hugo，使用 no-style-please主题搭建博客； 利用hugo的shortcodes功能，支持echarts； 图片等资源目前存储在七牛云的免费oss上； todo 下面是关于本博客未来将要做的一些事情：
搭建blog到gitpages上，可通过互联网访问； 将其他地方的blog维护或迁移到此处； 读书笔记版块建立起来； </description>
    </item>
    
    <item>
      <title>分布式数字身份（下）</title>
      <link>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8B/</link>
      <pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8B/</guid>
      <description>0. 前言 上篇我们从DID的相关基础概念和组成进行了介绍，为了更进一步的了解DID的的概念，本篇文章从用户工作跳槽，新入职公司需要验证用户去年个人收入进行定薪水的场景展开。
主要从场景描述、模型构建、验证过程、小结这四部分进行介绍。
场景描述：介绍个人收入证明场景下，参与方、验证过程、并对比同传统验证方案的区别和优势； 模型构建：结合实际场景，对DID架构中所使用的DID标识、DID DOC、可验证凭证及可验证表述数据模型进行构建； 验证过程：结合实际场景和构建的数据模型，描述验证过程中数据模型各部分结构在验证过程中的作用及验证原理； 小结：对上述三个主要部分内容进行总结； 1. 场景描述 1.1 传统验证过程 新入职员工验证薪资并根据工资水平进行定薪是一个非常常见的应用场景，大致过程如下：
入职员工通过提交上一家的工资流水证明来证明自己薪资水平，该证明一般通过向银行申请获得； 入职员工携带必要的材料去银行进行工资流水证明申请； 银行验证入职员工相关信息后，为其出示或打印工资流水证明，证明会附上银行的印章等； 入职员工携带材料去入职，并将银行开具的工资流水证明提交给新公司HR或其他相关人员； 新公司HR通过查看银行开具的工资流水证明能够获取该员工的工资收入情况并根据收入情况进行定薪； 上述过程是传统流程下的证明开具和验证流程，粗体部分是整个流程关键参与者或步骤。参与者有三个实体，分别为入职员工、银行、新公司HR，相关证明信息为工资流水证明，印章则能够反应该证明是银行所开具，证明所反映的信息为该员工去年收入情况。
// 图
1.2 基于DID验证过程 基于DID的验证流程的思想上同传统验证过程类似，也是根据证明信息来验证用户收入情况，不同之处在于在DID的体系下，代表实体身份的是不同的DID及对应的DID Doc，代表证明信息的是可验证凭证和可验证表述结构。
入职员工、银行、新公司会根据常见的密钥算法生成DID标识，相应的会生成DID Doc； 入职员工通过线上或线下方式向银行申请关于工资流水的可验证凭证； 2. 模型构建 3. 验证过程 5. 小结 6. 参考 </description>
    </item>
    
    <item>
      <title>分布式数字身份（上）</title>
      <link>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8A/</link>
      <pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liwh1227.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%B8%8A/</guid>
      <description>0. 前言 本篇内容基于W3C分布式数字身份相关调研内容，结合官方文档和调研过程中自己的一些理解进行整理，计划使用两篇文章进行描述，此为上篇，主要描述分布式数字身份的基本概念。
1. DID 首先，我们看下w3c关于分布式数字身份的定义： 大致要点如下：
去中心化标识符（DID）是一种新型标识符，能够实现可验证的去中心化数字身份； DID的控制权是在DID持有者身份上，持有者可以是任何主体（例如人、组织、物品、数据模型、抽象实体等），并且可以与中心化的注册表、身份提供者和证书机构分离； 具体而言，虽然其他方可能用于帮助启用与DID相关信息的发现，但DID的设计使控制者能够在不需要其他方许可的情况下证明对DID的控制权。 2. DID Document 与DID成对存在的是DID Document，DID Doc是对DID主体信息的进一步描述。不同DID主体之间能够通过阅读对方（这个阅读一般指机器意义上的识别）DID Doc获取有用身份代表信息，例如能够代表主体身份公钥信息及对应的密钥算法。 以下是基于公钥内容的DID Doc示例1：
{ &amp;#34;@context&amp;#34;: [ &amp;#34;https://www.w3.org/ns/did/v1&amp;#34;, &amp;#34;https://w3id.org/security/suites/ed25519-2020/v1&amp;#34; ], &amp;#34;id&amp;#34;: &amp;#34;did:example:123456789abcdefghi&amp;#34;, &amp;#34;authentication&amp;#34;: [{ &amp;#34;id&amp;#34;: &amp;#34;did:example:123456789abcdefghi#keys-1&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;Ed25519VerificationKey2020&amp;#34;, &amp;#34;controller&amp;#34;: &amp;#34;did:example:123456789abcdefghi&amp;#34;, &amp;#34;publicKeyMultibase&amp;#34;: &amp;#34;zH3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV&amp;#34; }] } @context: 代表的是该JSON-LD格式结构上下文2含义，主要目的是通过通过该上下文获取该结构中各字段的具体含义；
id: DID唯一标识；
authentication: 该字段用于确认用户对该DID的控制权，包含了与DID相关的公钥信息，用于验证DID控制器的身份和控制权。具体来说，该字段中的公钥信息可以用于验证DID控制器的数字签名，从而证明DID控制器对DID的控制权。
3. 可验证凭证 如图，W3C对可验证凭证定义： 一个标准的数据模型和表示格式，用于加密验证数字凭证，由W3C可验证凭证规范定义。
W3C定义的可验证凭证数据模型3：
{ &amp;#34;@context&amp;#34;: [ &amp;#34;https://www.w3.org/2018/credentials/v1&amp;#34;, &amp;#34;https://www.w3.org/2018/credentials/examples/v1&amp;#34; ], &amp;#34;id&amp;#34;: &amp;#34;http://example.edu/credentials/1872&amp;#34;, &amp;#34;type&amp;#34;: [ &amp;#34;VerifiableCredential&amp;#34;, &amp;#34;AlumniCredential&amp;#34; ], &amp;#34;issuer&amp;#34;: &amp;#34;https://example.edu/issuers/565049&amp;#34;, &amp;#34;issuanceDate&amp;#34;: &amp;#34;2010-01-01T19:23:24Z&amp;#34;, &amp;#34;credentialSubject&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;did:example:ebfeb1f712ebc6f1c276e12ec21&amp;#34;, &amp;#34;alumniOf&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;did:example:c276e12ec21ebfeb1f712ebc6f1&amp;#34;, &amp;#34;name&amp;#34;: [ { &amp;#34;value&amp;#34;: &amp;#34;Example University&amp;#34;, &amp;#34;lang&amp;#34;: &amp;#34;en&amp;#34; } ] } }, &amp;#34;proof&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;RsaSignature2018&amp;#34;, &amp;#34;created&amp;#34;: &amp;#34;2017-06-18T21:19:10Z&amp;#34;, &amp;#34;proofPurpose&amp;#34;: &amp;#34;assertionMethod&amp;#34;, &amp;#34;verificationMethod&amp;#34;: &amp;#34;https://example.</description>
    </item>
    
    <item>
      <title>关于go服务不停机升级的方案</title>
      <link>https://liwh1227.github.io/posts/%E5%85%B3%E4%BA%8Ego%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%BA%E5%8D%87%E7%BA%A7%E7%9A%84%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liwh1227.github.io/posts/%E5%85%B3%E4%BA%8Ego%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%BA%E5%8D%87%E7%BA%A7%E7%9A%84%E6%96%B9%E6%A1%88/</guid>
      <description>背景 在Go语言中，优雅地结束服务是一个非常重要的问题，因为它直接关系到服务的可靠性和稳定性。在传统的服务结束方式中，直接使用os.Exit()或syscall.Exit()等方法来结束服务，会导致服务无法优雅地退出，可能会出现一些问题，如未处理完的请求、未关闭的连接等。
目前项目的go服务主要用于接受外部app请求，根据请求信息进行相应逻辑处理后，将信息落库和上链。
我们要做到服务的优雅关闭，需要保证下面几类功能模块能够处理完请求后才退出：
http模块能够处理完成当前请求后正确退出； 消息队列模块能够将待消费的消息处理完成后退出； 未处理完的逻辑、监听区块链事件未处理完的逻辑等，保证能够在处理完成上述逻辑后再退出gateway服务，并且能够再某一个服务实例退出后，其他服务实例仍然可以工作。 实现方案 主要思路 gateway服务退出后，需要保证仍然能够对外提供相应的接口服务；
gateway通过docker容器方式运行，当我们停止docker容器时，需要使用 docker-compose down 或 docker-compose stop 命令结束服务。这两条命令会向容器发送系统中断信号，所以我们首先要考虑如何在容器收到结束信号时通知到服务；
gateway服务会启动http模块、消息队列模块以及区块链模块这三部分异步任务，我们需要考虑在退出主协程时如何保证上述三个子协程处理的模块能够在处理完当前逻辑后退出；
我们基于上述的3个问题分别进行解决，并通过demo代码进行演示。
实施方案 1. 负载均衡 为了保证某个服务停止后，仍然有其他实例能够对外提供服务，我们必须要对当前服务做负载均衡，这里是让运维同事通过nginx对gateway服务做了负载。这样就能保证某个实例停服更新时，可以将外部请求负载到其他的服务实例上。
通过上述三步基本能够保证优雅停机升级服务，但是在某些细节上还需要进行优化。
2. 处理和监听系统信号 使用 docker-compose down 或 docker-compose stop 命令进行docker容器停止，容器会收到 SIGTERM 中断信号，所以我们需要在服务中针对该信号进行捕捉和处理，主要处理方法如下：
package main import ( &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;syscall&amp;#34; ) func main() { signals := make(chan os.Signal, 1) signal.Notify(signals, syscall.SIGTERM, syscall.SIGINT) &amp;lt;-signals // do logic... } 开始时， signals 处于阻塞状态，当接收到上述SIGTERM 或 SIGINT信号后，说明运行容器要停止，进行系统退出后的逻辑处理。这里有一点需要注意，当我们运行上述命令后，容器会有默认停止的超时时间（10s），当超过该时间后系统会发送 SIGKILL 信号，
该信号无法被捕捉，为了保证服务能够最大程度的处理完业务逻辑，我们需要在停止容器时添加超时时间的命令， 例如：docker-compose down --timeout 120，将最大超时时间设置为120s，当超过这个时间后才会发送 SIGKILL 信号。</description>
    </item>
    
  </channel>
</rss>
